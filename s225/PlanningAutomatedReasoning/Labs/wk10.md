# Planning  a Heuristic
	the solution to the simpler problem heur estimate for the sol to the actual prob
## How to simplify a Planning Problem
### Abstraction via
	reduce the state space (e.g., PDB, M&S)
#### Developing the Heuristic 
1. *Homomorphism* - map state s where $s\in S$ to the same state in S'
2. *Calculate Distances* - get lower bound estimate
#### Transitions
1. *Full homomorphic mapping* - all goal states + transitions
2. *Block states* - map states to abstract states
	1. both states become the same
3. *Preserve Admissibility*
#### Patter Databases

# Sasha's Notes
## Question 1
![[Pasted image 20251007175654.png]]

## Question 2
a) Initial: OnTable(B), OnTable(C), On(A,B), Clear(A), Clear(B)
Actions: Stack(A,C), Stack(C,A), PutTable(A)/Unstack(A)
b) See photo. Keep it going until the solution is stable (i.e. when a layer gives the same results as
the previous layer)
PlanGraph Max is admissible, PlanGraph Sum is not (but will give us better results quicker)
c) Stack(C,B) and Stack(B,C) are mutually exclusive (AKA mutex). Keep in mind that mutexes are
temporary/time-bound; what is a mutex now may not be a mutex next move if we take the
right actions
Question 3
Thomas: Delete Relaxation is like having an instant save state at every move, so we can go back to
any
a) When calculating heuristics, we'll create a new "duplicate" box for each move, filling the
environment up with boxes
b) Can revert to pre-corner location to avoid screwing up
c) If there is no possible solution from the jump (e.g. if all boxes start in a corner), we still know
there is nothing we can do. The point is that Delete Relaxation doesn't give us the ability to do
anything we couldn't before, whereas a heuristic wouldn't necessarily tell us that it's
unsolvable.


