
# Implementation: 
Both agents might target the same food-desired behavior: If Agent 0 is going to food at (10, 5), Agent 1 should skip it and target the next closest food

  ---
  Solution Overview

  You need to do 3 things:

  1. Share target information between agents (using class variables in
  myTeam.py)
  2. Check what the other agent is targeting before selecting food (in
  astar_planner.py)
  3. Select the next closest food that isn't already targeted (in
  astar_planner.py)

  ---
  Step-by-Step Implementation

  Step 1: Share Target Information (myTeam.py)

  Agents can communicate through class variables (variables shared by all
  instances of the class).

  Where to add this:

  Find the CURRENT_ACTION class variable around line 96 in myTeam.py:

  class MixedAgent(CaptureAgent):
      # ... existing code ...

      CURRENT_ACTION = {}  # This already exists

  Add a new class variable right after it:

  CURRENT_ACTION = {}
  CURRENT_TARGET = {}  # â† ADD THIS LINE

  This creates a shared dictionary where:
  - Key = agent index (0, 1, 2, 3)
  - Value = the food position they're targeting

  ---
  Step 2: Update Target When Planning (myTeam.py)

  When an agent selects "attack" and gets a target, save it to the shared
  variable.

  Where to modify:

  Find the section around line 189-191 where the low-level plan is
  generated:

  if not self.posSatisfyLowLevelPlan(gameState):
      self.lowLevelPlan = self.astar_planner.getLowLevelPlan(gameState,
  highLevelAction)
      self.lowLevelActionIndex = 0

  Modify it to:

  if not self.posSatisfyLowLevelPlan(gameState):
      self.lowLevelPlan = self.astar_planner.getLowLevelPlan(gameState,
  highLevelAction)
      self.lowLevelActionIndex = 0

      # Save our target position for teammate coordination
      if highLevelAction == "attack" and len(self.lowLevelPlan) > 0:
          # The last position in our plan is our target food
          target_pos = self.lowLevelPlan[-1][1]
          MixedAgent.CURRENT_TARGET[self.index] = target_pos
      elif highLevelAction == "go_home":
          # Clear our target when going home
          MixedAgent.CURRENT_TARGET[self.index] = None

  Explanation:
  - When attacking, save the final target position
  - When going home, clear the target so teammate knows you're not targeting
   food anymore

  ---
  Step 3: Pass Teammate's Target to A Planner (myTeam.py)*

  The A* planner needs to know what food to avoid. Modify how you call
  getLowLevelPlan().

  Find this line (around line 190):

  self.lowLevelPlan = self.astar_planner.getLowLevelPlan(gameState,
  highLevelAction)

  Change it to:

  # Get teammate's target
  teammate_target = self._getTeammateTarget()

  # Pass teammate target to A* planner
  self.lowLevelPlan = self.astar_planner.getLowLevelPlan(gameState,
  highLevelAction, teammate_target)

  ---
  Step 4: Add Helper Function to Get Teammate Target (myTeam.py)

  Add this new function anywhere in the MixedAgent class (I suggest after
  chooseAction):

  def _getTeammateTarget(self):
      """
      Get the food position that our teammate is currently targeting
      Returns None if teammate has no target
      """
      # Get our team indices
      team = self.getTeam(self.getCurrentObservation())

      # Find teammate's index (not our index)
      for teammate_index in team:
          if teammate_index != self.index:
              # Return teammate's target (or None if they don't have one)
              return MixedAgent.CURRENT_TARGET.get(teammate_index, None)

      return None

  Explanation:
  - Finds your teammate's index
  - Looks up their target in the shared CURRENT_TARGET dictionary
  - Returns None if they're not targeting anything

  ---
  Step 5: Modify A Planner to Accept Teammate Target (astar_planner.py)*

  Find the getLowLevelPlan function signature (around line 76):

  def getLowLevelPlan(self, gameState, highLevelAction: str) -> 
  List[Tuple[str, Tuple]]:

  Change it to:

  def getLowLevelPlan(self, gameState, highLevelAction: str, 
  exclude_food=None) -> List[Tuple[str, Tuple]]:

  Add a docstring comment:

  def getLowLevelPlan(self, gameState, highLevelAction: str, 
  exclude_food=None) -> List[Tuple[str, Tuple]]:
      """
      Generate a low-level plan (sequence of moves) to achieve high-level 
  action
      
      Args:
          gameState: Current game state
          highLevelAction: High-level action to execute ("attack" or 
  "go_home")
          exclude_food: Food position to avoid (teammate's target), or None
      
      Returns: List of (action, target_position) tuples
      """

  ---
  Step 6: Pass Excluded Food to _getTarget (astar_planner.py)

  In getLowLevelPlan, find this line (around line 83):

  target = self._getTarget(gameState, highLevelAction)

  Change it to:

  target = self._getTarget(gameState, highLevelAction, exclude_food)

  ---
  Step 7: Modify _getTarget to Accept Excluded Food (astar_planner.py)

  Find the _getTarget function signature (around line 113):

  def _getTarget(self, gameState, highLevelAction: str) -> 
  Optional[Tuple[int, int]]:

  Change it to:

  def _getTarget(self, gameState, highLevelAction: str, exclude_food=None) 
  -> Optional[Tuple[int, int]]:

  Update the function body to pass exclude_food:

  def _getTarget(self, gameState, highLevelAction: str, exclude_food=None) 
  -> Optional[Tuple[int, int]]:
      """
      Determine target location based on high-level action
      Simple version: only handles attack and go_home
      
      Args:
          exclude_food: Food position to exclude (teammate's target)
      """
      if highLevelAction == "attack":
          # Target: Nearest food in enemy territory (excluding teammate's 
  target)
          return self._getNearestFood(gameState, exclude_food)
      elif highLevelAction == "go_home":
          # Target: Home boundary (safest entry point)
          return self._getHomeBoundary(gameState)
      else:
          # Default: nearest food
          return self._getNearestFood(gameState, exclude_food)

  ---
  Step 8: Modify _getNearestFood to Skip Excluded Food (astar_planner.py)

  This is the key part! Here you filter out the teammate's target.

  Find _getNearestFood (around line 128):

  def _getNearestFood(self, gameState) -> Optional[Tuple[int, int]]:
      """
      NECESSARY TO IMPLEMENT (Due to above function)
      Find nearest food pellet in enemy territory"""
      myPos = gameState.getAgentPosition(self.agent.index)
      print("My Position:", myPos)
      foodList = self.agent.getFood(gameState).asList()
      print("Food List:", foodList)
      if len(foodList) > 0:
          # Return closest food (use Manhattan distance)
          def manhattan(f):
              return abs(f[0] - myPos[0]) + abs(f[1] - myPos[1])
          return min(foodList, key=manhattan)
      return None

  Replace it with:

  def _getNearestFood(self, gameState, exclude_food=None) -> 
  Optional[Tuple[int, int]]:
      """
      Find nearest food pellet in enemy territory
      
      Args:
          exclude_food: Food position to exclude (teammate's target)
      """
      myPos = gameState.getAgentPosition(self.agent.index)
      foodList = self.agent.getFood(gameState).asList()

      # Filter out teammate's target food
      if exclude_food is not None and exclude_food in foodList:
          print(f"Agent {self.agent.index}: Excluding teammate's target 
  {exclude_food}")
          foodList = [f for f in foodList if f != exclude_food]

      if len(foodList) > 0:
          # Return closest food (use Manhattan distance)
          def manhattan(f):
              return abs(f[0] - myPos[0]) + abs(f[1] - myPos[1])
          closest = min(foodList, key=manhattan)
          print(f"Agent {self.agent.index}: Targeting food at {closest}")
          return closest

      return None

  Explanation:
  - Takes exclude_food parameter
  - Filters out that food from the list: foodList = [f for f in foodList if 
  f != exclude_food]
  - Returns the closest food from the remaining options

  ---
  Complete Summary of Changes

  myTeam.py:

  1. Add CURRENT_TARGET = {} class variable
  2. Save target when creating low-level plan
  3. Add _getTeammateTarget() helper function
  4. Pass teammate target to A* planner

  astar_planner.py:

  1. Add exclude_food parameter to getLowLevelPlan()
  2. Pass exclude_food to _getTarget()
  3. Add exclude_food parameter to _getTarget()
  4. Pass exclude_food to _getNearestFood()
  5. Add exclude_food parameter to _getNearestFood()
  6. Filter out excluded food from food list

  ---
  How to Test

  After making these changes, run:

  python3 capture.py -r myTeam.py -b staffTeam.py

  Watch the console output: You should see messages like:
  Agent 0: Targeting food at (10, 5)
  Agent 1: Excluding teammate's target (10, 5)
  Agent 1: Targeting food at (12, 7)

  ---
  Quick Debugging Tips

  If agents still target the same food:
  1. Check that CURRENT_TARGET is being set (add print statements)
  2. Check that exclude_food is not None (add print statements)
  3. Verify the food position format matches (both should be tuples like (x,
   y))
