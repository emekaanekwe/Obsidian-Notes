# Wk 2

![[FIT3181_5215-W2_Quiz.pdf]]


# Wk3

![[FIT3181_5215-L04-Quiz.pdf]]

### Calculate Output Tensor, given 3D tensor
*The same process applies to pooling*
![[Pasted image 20250910100303.png]]

### Calculate the Output Tensor Shape
![[Pasted image 20250910100731.png]]
$$Tensorshape = [CNN[0], Filters, H_{out}, W_{out}]$$

### Tensor Shape from Code

```Python
import torch
import torch.nn as nn

cnn = nn.Sequential(
    nn.Conv2d(3, 32, kernel_size=3, stride=2, padding=1),  # Note: stride=2 (not 3)
    nn.ReLU(),
    nn.Conv2d(32, 64, kernel_size=3, stride=1, padding=1),
    nn.ReLU()
)

x = torch.rand(1, 3, 224, 224)  # Input shape: [batch_size=1, channels=3, height=224, width=224]
print(cnn(x).shape)
```

Using $H_{out} \ and \ W_{out}$, the output shape before ReLu is [1,32,112,112]
Putting it through again, we get [1,64,112,112]

For **`Conv2d(), ReLu()`**
	input shape = $[1,3,224,224]$, output shape =  $[1*1, 3*32(first), 224/2, 224/2]$

For `BatchNorm(), MaxPool()`
	input shape = $[initial, Conv2d(width, pass2), size/4,size/4]$, output shape =  $[64, 64, 56, 56]$

### Calculate the # of Neurons

$$NeuronNum = Filters \times  W_{out} \times H_{out}$$

### Causes of Overfitting

#### Large Filter + Deep Models + Few Images

### Formal Structure of CNNs
![[Pasted image 20250910103524.png]]

$$\begin{matrix}  Input := [A1,B1,C1,D1] = [Total \ Layers, Preprocess \ Layers, Height, Width] \\ Filter := [F1,F2,F3,F4]=[Total \ Filters, Processed, Height, Width]\\ Pooling(Feature1) := [A2, B2, C2, D2] = [Total \ Features, Feature1 \ Layers \ \#, Width, Height] \\ Pooling(Feature2) := [A3, B3, C3, D3] = [Total \ Features, Feature2 \ Layers \ \#, Width, Height] \\ FC:= [E, F] = [Height, Width (4, 256)] \\ SoftMax := [G, H]=[\# \ of \ Neurons, \# \ of \ Classes ]    \end{matrix} $$

### Row 2 of CNN post-softmax

Assume a tensor shapeÂ `[4, 10]`:
    The first dimension (size 4) is theÂ **batch size**Â (i.e., there are 4 images in the batch).
    The second dimension (size 10) is theÂ **number of classes**Â (e.g., for a classification task with 10 categories).
Since the tensor isÂ **after softmax**, each row represents theÂ *prediction probabilities*Â for an image in the batch

### Purpose of Conv2D Tensors

#### 1. Dimension reduction
#### 2. Pattern detection filtering

### Purpose of Pooling Layers

#### 1. Preserve input integrity
#### 2. Reduce input size

### Purpose of Batch Norm Layers

#### 1. Mitigate Overfitting
#### 2. Get the Gaussian distro of training data and testing data




# Wk4

![[FIT3181-5215-L4-Quiz.pdf]]



### FF Networks: Optimization Problems

#### Concerning regularization $\Omega(\theta)$
$$min_ğœƒ ğ½( ğœƒ) = ğ›º ğœƒ + 1/N \sum^N_{i=1}CE(y_i,f(x;\theta))$$

$\theta$ is the weight and bias at a particular part of the loss
$\Omega (\theta)$ is the regularizer, i.e. sum of the eigenvalues to **prevent over fitting**, **makes the model simpler**, and **iterates the weights towards 0**

#### Concerning the empirical loss $\frac{1}{N} \sum^N_{i=1}CE(y_i,f(x;\theta))$
$$min_ğœƒ ğ½( ğœƒ) = ğ›º ğœƒ + 1/N \sum^N_{i=1}CE(y_i,f(x;\theta))$$
$f(x;\theta)$ is the prediction Pr, the empirical loss **improves model fitting to training set**, but **could over fit**

### Calculating GD

#### Update Rule
$$Î¸t+1â€‹=Î¸tâ€‹âˆ’Î·â‹…âˆ‡f(Î¸tâ€‹)$$

Assume:        $f(Î¸)=Î¸^2âˆ’2Î¸+1$, learning rate: $0.1$, 
**compute** the gradient ofÂ $f(Î¸)$Â with respect toÂ $Î¸$:

We can treat the formula like a quadratic equation: $f(x) = x^2+x+c$
	get the derivative
	then **plug back into the update rule**
	calculate the derivative again if needed

### Calculating SGD

Assume: there are 4 indices
#### Update rule
$$Î¸t+1â€‹=Î¸tâ€‹âˆ’Î·â‹…âˆ‡f^â€‹(Î¸tâ€‹)$$
#### Mini Batch Loss
$$\hat{f}^â€‹(Î¸)=\frac{1}{4}âˆ‘^{4}_{j=1}â€‹(Î¸âˆ’i_jâ€‹)^2$$
1. plug in the values assumed in the batch loss
2. compute the gradient for $\hat{f}$
	$$âˆ‡f^â€‹(Î¸)=â€‹f'^â€‹(Î¸)=\frac{1}{4}\times\frac{d}{dx}\sum$$
	which requires the derivative of each term. $$(Î¸âˆ’1â€‹)^2+(Î¸âˆ’2)^2+(Î¸âˆ’3â€‹)^2+(Î¸âˆ’4)^2$$
plug in the $\theta$ value and compute:$$...(Î¸=10âˆ’x_i)^2...$$
apply the SGD update by plugging in all the values:
$$Î¸t+1â€‹=Î¸tâ€‹âˆ’Î·â‹…âˆ‡f^â€‹(Î¸tâ€‹)$$

### $minL()$ Optimization Problem

#### Structure
$$min ğœƒ ğ¿ ğ·; ğœƒ â‰” -\frac{1}{ğ‘}\sum  \Delta  ğ‘™(ğ‘¥_{i_k}, ğ‘¦{i_k}; ğœƒ) $$
notice how the updating is **negative** for $x_k$ **batches**

### Gradient and BP via Code
Consider:
```Python
x = torch.tensor([1.0,2.0,3.0], requires_grad=False)
y = torch.tensor([4.0])
W = torch.rand(3,1, requires_grad=True)
b = torch.rand(1, requires_grad=True)

y_hat = torch.matmul(x,W)+b
l = (y_hat - y)**2

# BP
l.bakward(retain_graph=True)

```

1. Computes the gradient of loss for weight **and** bias
2. weight and bias both **store the training data** and **real values**
3. For BP, computes back to **previous weights** and goes **from $\hat{y}$ to x**

### Activation Functions in Code

#### Sigmoid
```Python
 1./(1+np.exp(-x))
```
#### ReLU
```Python
 x*(x>0)
```
#### tanH (hyperbolic)
```Python
 (np.exp(n)-1.)/(np.exp(n)+1.) 
```
#### softmax
```Python
 np.exp(x)/np.sum(np.exp(x))
```

### Calculating Activation Functions

#### Which is ğœ•â„ ğœ•â„ if â„ = ğœ(â„), â„ is a vector and ğœ is an activation function?
$Diag(\sigma'(\hat{h}))$, or $I$

#### ReLU calculation
Simply reduce the matrix to diag 1