$$
\text{There is a set of nodes n }\epsilon N\atop
\text{where for any } (n_1 ... n_n) \text{ n is surjective}

$$

| Category                           | Term                       | Definition                                                                                                                                                                                                                                                                                                                                                        | Complete? | Optimal? | O-Complexity                                                                                                | Use Cases                                 | Problems                                                                                       | Example                          |
| ---------------------------------- | -------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------- | -------- | ----------------------------------------------------------------------------------------------------------- | ----------------------------------------- | ---------------------------------------------------------------------------------------------- | -------------------------------- |
| Algorithm, Search, Uninformed      | Breadth-First              | Given a tree T with nodes n, root(Tn) expanded as uniform depth                                                                                                                                                                                                                                                                                                   |           |          | O(b^d)                                                                                                      | finding shortest path for unweighted tree |                                                                                                | garbage collection; P2P networks |
| Algorithm, Search, Uninformed      | Dijkstra/Uniform-Cost      | BFS, but exands based on path cost. expands the lowest cost first.                                                                                                                                                                                                                                                                                                |           |          | O(b^(1+[C*/e]) where C* is the cost of the optimal solution and e is the lower bound on cost of each action |                                           | blindly searching, which can be memory inefficient                                             |                                  |
| Algorithm, Search, Uninformed      | Depth-First Search         | Given a tree T with nodes n, root(Tn) deepest node expanded first                                                                                                                                                                                                                                                                                                 | Yes       | Yes      |                                                                                                             |                                           | returns first solution found. not cost-optimal. if state space is cyclical, can run infinitely |                                  |
| Algorithm, Search, Uninformed      | Depth-Limited              | supply a depth limit L and assume L has no successors                                                                                                                                                                                                                                                                                                             |           |          | O(b^L)                                                                                                      |                                           | human can choose an L that has no solution                                                     |                                  |
| Algorithm, Search, Uninformed      | Iterative Deppening        | depth-limited search with adding constraints each cycle. Does                                                                                                                                                                                                                                                                                                     |           |          | O(b^d) where d is depth                                                                                     |                                           | Does not keep track of reached states                                                          |                                  |
| Algorithm, Search, Uninformed      | Bidirectional              | simultaneously goes search from initial state and backwards from goal state                                                                                                                                                                                                                                                                                       |           |          | O(b^(d/2))                                                                                                  |                                           |                                                                                                |                                  |
| Algorithm, Search, Informed*       | Greedy Best-First          | expands node with minimal h(n) while ignoring best costs                                                                                                                                                                                                                                                                                                          |           |          | O(\|V\|)                                                                                                    |                                           | depending not complete like DFS, but as graph search it is.                                    |                                  |
|                                    | A*                         | Best-First Uniform with an evaluation function f(n)=g(n)+h(n). relaxation occurs.                                                                                                                                                                                                                                                                                 | Yes       | Yes      | O(b^(e/cost))                                                                                               |                                           |                                                                                                |                                  |
| Local Search, Optimization         | Local                      | no memory of paths or reached states. Contain an objective function                                                                                                                                                                                                                                                                                               |           |          |                                                                                                             |                                           |                                                                                                |                                  |
|                                    | Hill Climbing/Greedy Local | gradient decsent but only with aim to find a max for concave functions                                                                                                                                                                                                                                                                                            |           |          |                                                                                                             |                                           | most functions are not concave                                                                 | 8 queens problem                 |
|                                    | Simulated Annealing        | stochastic gradient descent max, picks random move and evaluates each one                                                                                                                                                                                                                                                                                         |           |          |                                                                                                             |                                           |                                                                                                |                                  |
|                                    | Local Beam                 | checks a random set of states k, and checks successors, then selects the best one                                                                                                                                                                                                                                                                                 |           |          |                                                                                                             |                                           | can get stuck at local min                                                                     |                                  |
| Algorithms, Search, Evolutionary** | Genetic***                 | each "node" is a boolean string, with selection (highest value), crossover point (recombination), mutation (probability of successors' bits in string are flipped), elitism with any nodes below highest value are discarded. "take one part of path that works and another and combine them to make a new one with small Pr of mutations or rearranging of bits" |           |          |                                                                                                             |                                           |                                                                                                |                                  |
| CSP                                |                            |                                                                                                                                                                                                                                                                                                                                                                   |           |          |                                                                                                             |                                           |                                                                                                |                                  |
\*All informed searches have a heuristic function. A **domain-dependent** (a rule of thumb for the specific problem at hand) function h(n)= estimated cost of cheapest/closest path from n to goal. These things are learned.

\** these are often considered solutions to the limitations of hill climbing and local search. Similar to stochastic beam search where the population (states) with highest value's offspring (successors) are checked

\*** these come with a *fitness function* where we have knowledge of a goal. 
	**but that's false regarding natural selection, unless we accept a begging of the question of identifying fitness**
	
## Add To Notes
1. Heuristic properties
	1. relaxed problems and optimization (admissible heuristics), i.e. never overestimates the cost
	2. consistency: if all n and successors, parent has to be less than or equal to cost 
		1. if search is 1, but not 2, A* can still give a solution but may not be optimal
2. tie breaking
3. Need to ask the questions for algos. **Add to columns**
	1. complete?
	2. Optimal?
	3. Time?
	4. Space?
4. use the 8 queens problem for explaining local search
5. details and prblems of hill climbing and local search
	1. https://www.geeksforgeeks.org/introduction-hill-climbing-artificial-intelligence/#advantages-of-hill-climbing-algorithm
6. 
## Additional Research
1. ant colony optimization
2. in Russell, consistency => admissability
3. what are the cases in which djikstra outperforms A* in O-time?
![[Screenshot from 2025-03-17 13-30-48.png]]
![[Screenshot from 2025-03-17 13-31-30.png]]